// Collection: mount a local directory with a certain path spec
local.file_match "applogs" {
    path_targets = [{"__path__" = "/logs/*.log"}]
}

// Collection: Take the file match as input, and scrape those mounted log files
loki.source.file "local_files" {
    targets    = local.file_match.applogs.targets

    // This specifies which component should process the logs next, the "link in the chain"
    forward_to = [loki.process.add_new_label.receiver]
}

// Transformation: pull some data out of the log message, and turn it into a label

loki.process "add_new_label" {
  stage.regex {
    expression = "^(?P<ts>\\S+)\\s+(?P<level>INFO|DEBUG|WARN|ERROR)\\s+(?P<pid>\\d+)\\s+---\\s+\\[(?P<thread>[^]]+)\\]\\s+\\[(?P<executor>[^]]+)\\]\\s+(?P<class>[^:]+)\\s+:\\s(?P<msg>.*)$"
  }

  // Add parsed fields as labels
  stage.labels {
    values = {
      "level"   = "level",
      "thread"  = "thread",
      "executor"= "executor",
      "class"   = "class",
      "job"     = "OAuth2.1",
    }
  }

  forward_to = [loki.write.local_loki.receiver]
}



// Anything that comes into this component gets written to the loki remote API
loki.write "local_loki" {
    endpoint {
        url = "http://loki:3100/loki/api/v1/push"
    }
}

//Alloy log
logging {
  level    = "debug"
  format   = "json"
  write_to = [loki.write.alloy_logs.receiver]
}

loki.write "alloy_logs" {
  endpoint {
    url = "http://loki:3100/loki/api/v1/push"
  }
}